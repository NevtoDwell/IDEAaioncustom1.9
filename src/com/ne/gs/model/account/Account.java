/*
 * This file is part of Neon-Eleanor project
 *
 * This is proprietary software. See the EULA file distributed with
 * this project for additional information regarding copyright ownership.
 *
 * Copyright (c) 2011-2013, Neon-Eleanor Team. All rights reserved.
 */
package com.ne.gs.model.account;

import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import com.ne.commons.shared.AccountTime;
import com.ne.gs.model.Race;
import com.ne.gs.model.items.storage.Storage;

/**
 * This class represents game account and is holding such informations as:
 * <ul>
 * <li>account id</li>
 * <li>account name</li>
 * <li> {@link AccountTime account time info}</li>
 * <li>a list of {@link PlayerAccountData} objects each of which keeping information about player that must be available on character selection screen.</li>
 * </ul>
 *
 * @author SoulKeeper
 * @modified cura
 */
public class Account implements Iterable<PlayerAccountData> {

    /**
     * Unique id of this account (it's generated by login server)
     */
    private final int id;
    /**
     * Unique name of this account
     */
    private String name;
    /**
     * Access level
     */
    private byte accessLevel;
    /**
     * Membership of this account
     */
    private byte membership;

    private long expire;

    private AccountTime accountTime;

    private final Map<Integer, PlayerAccountData> players = new HashMap<>(1);

    private Storage accountWarehouse;

    private int numberOfAsmos = 0;

    private int numberOfElyos = 0;

    private CharacterPasskey characterPasskey;

    public Account(int id) {
        this.id = id;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public AccountTime getAccountTime() {
        return accountTime;
    }

    public void setAccountTime(AccountTime accountTime) {
        this.accountTime = accountTime;
    }

    /**
     * @return the accessLevel
     */
    public byte getAccessLevel() {
        return accessLevel;
    }

    /**
     * @param accessLevel
     *     the accessLevel to set
     */
    public void setAccessLevel(byte accessLevel) {
        this.accessLevel = accessLevel;
    }

    /**
     * @return the membership
     */
    public byte getMembership() {
        return membership;
    }

    /**
     * @param membership
     *     the membership to set
     */
    public void setMembership(byte membership) {
        this.membership = membership;
    }

    public long getExpire() {
        return expire;
    }

    public void setExpire(long expire) {
        this.expire = expire;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }

        if (!(o instanceof Account)) {
            return false;
        }

        Account account = (Account) o;

        return id == account.id;
    }

    @Override
    public int hashCode() {
        return id;
    }

    /**
     * @param chaOid
     *
     * @return PlayerAccountData
     */
    public PlayerAccountData getPlayerAccountData(int chaOid) {
        return players.get(chaOid);
    }

    /**
     * @param accPlData
     */
    public void addPlayerAccountData(PlayerAccountData accPlData) {
        players.put(accPlData.getPlayerCommonData().getPlayerObjId(), accPlData);
        switch (accPlData.getPlayerCommonData().getRace()) {
            case ASMODIANS:
                numberOfAsmos++;
                break;
            case ELYOS:
                numberOfElyos++;
                break;
        }
    }

    /**
     * @return the accountWarehouse
     */
    public Storage getAccountWarehouse() {
        return accountWarehouse;
    }

    /**
     * @param accountWarehouse
     *     the accountWarehouse to set
     */
    public void setAccountWarehouse(Storage accountWarehouse) {
        this.accountWarehouse = accountWarehouse;
    }

    /**
     * @return the characterPasskey
     */
    public CharacterPasskey getCharacterPasskey() {
        if (characterPasskey == null) {
            characterPasskey = new CharacterPasskey();
        }
        return characterPasskey;
    }

    /**
     * Returns the number of players that are on this account
     */
    public int size() {
        return players.size();
    }

    /**
     * Returns the number of players that are on this account and not delete
     */
    public int sizeNotDelete() {
        int size = 0;
        for (PlayerAccountData pad : players.values()) {
            if (pad.getDeletionTimeInSeconds() == 0) {
                size++;
            }
        }
        return size;
    }


    /**
     * Sorts the accounts on last online.
     */
    public ArrayList<PlayerAccountData> getSortedAccountsList() {
        ArrayList<PlayerAccountData> list = new ArrayList<>();
        list.addAll(players.values());
        Collections.sort(list, new Comparator<PlayerAccountData>() {

            @Override
            public int compare(PlayerAccountData x, PlayerAccountData y) {
                Timestamp t1 = x.getPlayerCommonData().getLastOnline();
                Timestamp t2 = y.getPlayerCommonData().getLastOnline();
                if (t2 == null) {
                    return 1;
                } else if (t1 == null) {
                    return -1;
                }
                return y.getPlayerCommonData().getLastOnline().compareTo(x.getPlayerCommonData().getLastOnline());
            }
        });
        return list;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Iterator<PlayerAccountData> iterator() {
        return players.values().iterator();
    }

    public int getNumberOf(Race race) {
        switch (race) {
            case ASMODIANS:
                return numberOfAsmos;
            case ELYOS:
                return numberOfElyos;
        }
        return 0;
    }

    public void decrementCountOf(Race race) {
        switch (race) {
            case ASMODIANS:
                numberOfAsmos--;
                break;
            case ELYOS:
                numberOfElyos--;
                break;
        }
    }

    public boolean isEmpty() {
        return numberOfAsmos == 0 && numberOfElyos == 0;
    }

    public int getMaxPlayerLevel() {
        int maxLevel = 1;
        for (PlayerAccountData pad : players.values()) {
            if (pad.getPlayerCommonData().getLevel() > maxLevel) {
                maxLevel = pad.getPlayerCommonData().getLevel();
            }
        }
        return maxLevel;
    }

    @Override
    public String toString() {
        return "Account [id=" + id + ", name=" + name + "]";
    }
}
